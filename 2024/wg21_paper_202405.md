# ［C++］WG21月次提案文書を眺める（2024年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-05)

全部で139本あります。

もくじ

[:contents]

### [N4983 WG21 agenda: 24-29 June 2024, St. Louis, MO, USA](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4983.html)

2024年6月にセントルイスで行われた会議のアジェンダ。

### [P0260R9 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r9.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)

このリビジョンでの変更は

- 提案する文言の拡充
- `capacity`の修正
- `push()/pop()`の文言に"strongly happens before"を使うように変更
- discussion pointsを追加
- コンストラクタとデストラクタが同じスレッドに戻ることに関する段落を削除
- `try_*`はブロックしなくなった
- `try_*`のspurious failureに関する文言を追加
- キューを事前に埋める`bounded_queue`のコンストラクタを削除
- P3282への参照を追加
- `try_push(T &&, T &)`に関する議論をHistoric Contentsに移動

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0843R12 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r12.html)

静的な最大キャパシティを持ちヒープ領域を使用しない`std::vector`である`inplace_vector`の提案。

以前の記事を参照

- [P0843R5 static_vector - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P0843R5-static_vector)
- [P0843R6 static_vector - ［C++］WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P0843R6-static_vector)
- [P0843R8 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P0843R8-inplace_vector)
- [P0843R9 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P0843R9-inplace_vector)
- [P0843R10 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P0843R10-inplace_vector)
- [P0843R11 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0843R11-inplace_vector)

このリビジョンでの変更は

- 以前のリビジョンを復帰して、条件付き`constexpr`を有効化
- R8で削除された`constexpr`対応の議論を再導入

などです。

この提案は、2024年6月の全体会議でC++26に向けて採択されています。

- [P0843 進行状況](https://github.com/cplusplus/papers/issues/114)

### [P0963R2 Structured binding declaration as a condition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0963r2.html)

構造化束縛宣言を条件式を書くところで書けるようにする提案。

以前の記事を参照

- [P0963R1 Structured binding declaration as a condition - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P0963R1-Structured-binding-declaration-as-a-condition)

このリビジョンでの変更は、分解前に条件をチェックするという評価順序を規定しそれについての議論を追加したことと、提案する文言の改善などです。

この提案は、2024年6月の全体会議でC++26に向けて採択されています。

- [P0963 進行状況](https://github.com/cplusplus/papers/issues/1617)

### [P1000R6 C++ IS schedule](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1000r6.pdf)

C++26策定までのスケジュールなどを説明した文書。

このリビジョンはR5のものとほぼ同じですが、決定済みの会議開催地の地名が記載されるようになっています。

### [P1083R8 Move resource_adaptor from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1083r8.html)

`pmr::resource_adaptor`をLibrary Foundermental TSからワーキングドラフトへ移動する提案。

以前の記事を参照

- [P1083R4 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1083R4-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R5 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P1083R5-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R6 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P1083R6-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R7 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1083R7-Move-resource_adaptor-from-Library-TS-to-the-C-WP)

このリビジョンでの変更は、`resource-adaptor-imp`に可変長引数コンストラクタを追加した事などです。

この提案は現在LWGでレビュー中です。

- [P1083 進行状況](https://github.com/cplusplus/papers/issues/33)

### [P1112R5 Language support for class layout control](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1112r5.pdf)

クラスレイアウトを明示的に制御するための構文の提案。

以前の記事を参照

- [P1112R4 Language support for class layout control - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1112R4-Language-support-for-class-layout-control)

このリビジョンでの変更は

- Cでは構造体メンバの宣言順調整でこの問題を解消できるが、C++ではそれは実行可能ではないことについての説明の追加
- リフレクションではこの問題を解決できないことについてのセクションを追加
- Design principlesセクションを追加
- `eval`ストラテジーを追加
- `smallest`を`small`に変更し、アルゴリズムの説明を追加
- 対象読者を追加
- 文言作成に関する戦略を追記

などです。

今回レイアウトに関する指示を行う方法が1つ追加されました

- `layout(eval(consteval_func))`
  - 元のレイアウトをエントリーの配列として取得し、オフセットフィールドを変更できる`consteval`関数を呼び出す

`layout(eval(func))`に渡す`consteval`関数は、レイアウトを変更する場合に`true`を返し、変更しないならば`false`を返す必要があります。そして、その引数には次のような構造体の配列が渡されます

```cpp
// クラスの元のレイアウトについての、各メンバ毎の情報を持つ
struct layout_entry {
  enum type_id { base, member, tech };
  type_id type;
  string_view name; // メンバ名
  size_t index;     // 宣言順のインデックス
  size_t size;      // sizeof()の結果の値
  int alignment;    // alignas()の結果の値
  bool noua;        // [[no_unique_address]]の有無
  bool fixed;       // ムーブ可能かどうか
  size_t orig_offset;    // 元のレイアウトにおけるオフセット
  mutable size_t offset; // 変更するオフセット（初期値はorig_offsetの値）
};

// layout(eval(f))に渡す関数の例
consteval bool my_layout_func(span<const layout_entry> entries);
```

これによって、プログラマはかなり詳細にそのオフセットを制御することができるようになります。

この提案はこれ以上追求しないことがEWGで決定されたようです。

- [P1112 進行状況](https://github.com/cplusplus/papers/issues/38)

### [P1144R11 `std::is_trivially_relocatable`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r11.html)

オブジェクトの再配置（*relocation*）という操作を定義し、それをサポートするための基盤を整える提案。

以前の記事を参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R7 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年04月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P1144R7-stdis_trivially_relocatable)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P1144R9 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P1144R9-stdis_trivially_relocatable)
- [P1144R10 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P1144R10-stdis_trivially_relocatable)

このリビジョンでの変更は

- この提案に準拠済みのライブラリについての参照の追加
- `uninitialized_relocate_n`のテンプレートパラメータのために`NoThrowInputIterator`要件を追加
- P3279への相互参照を追加

などです。

- [P1144 進行状況](https://github.com/cplusplus/papers/issues/43)

### [P1255R13 A view of 0 or 1 elements: views::nullable And a concept to constrain maybes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1255r13.pdf)

任意のオブジェクトや`std::optional`等のmaybeモナドな対象を要素数0か1のシーケンスに変換するRangeアダプタ`views::maybe`/`views::nullable`の提案。

以前の記事を参照

- [P1255R6 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R7 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1255R7-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R8 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P1255R8-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R9 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P1255R9-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R10 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P1255R10-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R12 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P1255R12-A-view-of-0-or-1-elements-viewsmaybe)

このリビジョンでの変更は

- `views::maybe`を削除し、`std::optional`の`range`化を好む
- `std::maybe`コンセプトの追加
- `std::optional`やポインタ型など`maybee`型のためのフリー関数を追加

などです。

`std::maybe`コンセプトは次のような単純なものです

```cpp
template <class T>
concept maybe = requires(const T t) {
  bool(t);
  *(t);
};
```

これに対して次のフリー関数を追加します

```cpp
template <class T, class R = optional<decay_t<T>>>
constexpr auto yield_if(bool b, T&& t) -> R {
  return b ? forward<T>(t) : R{};
}

template <maybe T,
          class U,
          class R = common_reference_t<iter_reference_t<T>, U&&>>
constexpr auto reference_or(T&& m, U&& u) -> R {
  static_assert(!reference_constructs_from_temporary_v<R, U>);
  static_assert(!reference_constructs_from_temporary_v<R, T&>);
  return bool(m) ? static_cast<R>(*m) : static_cast<R>((U&&)u);
}

template <maybe T,
          class U,
          class R = common_type_t<iter_reference_t<T>, U&&>>
constexpr auto value_or(T&& m, U&& u) -> R {
  return bool(m) ? static_cast<R>(*m) : static_cast<R>(forward<U>(u))
}

template <maybe T,
          class I,
          class R = common_type_t<iter_reference_t<T>,
          invoke_result_t<I>>>
constexpr auto or_invoke(T&& m, I&& invocable) -> R {
  return bool(m) ? static_cast<R>(*m) : static_cast<R>(invocable());
}
```

- [P1255 進行状況](https://github.com/cplusplus/papers/issues/60)

### [P1306R2 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1306r2.pdf)

コンパイル時にステートメントをループ生成することのできる、展開ステートメントの提案。

展開ステートメントとは、通常の`range`（配列や`std::vector`等コンテナ）に加えてタプルやクラス、波かっこのリストを反復することのできるコンパイル時のループ構文であり、ループの結果としてはループ本体のコード（ステートメント）をループの度にその場に展開していきます。

例えば次のような拡張ステートメントは

```cpp
auto tup = std::make_tuple(0, ‘a’, 3.14);
template for (auto elem : tup) {
  std::cout << elem << std::endl;
}
```

次のようにコードをべた書きしたのと等価になります

```cpp
auto tup = std::make_tuple(0, ‘a’, 3.14);
{
  auto elem = std::get<0>(tup);
  std::cout << elem << std::endl;
}
{
  auto elem = std::get<1>(tup);
  std::cout << elem << std::endl;
}
{
  auto elem = std::get<2>(tup);
  std::cout << elem << std::endl;
}
```

また展開ステートメントでは、波かっこリストが特別扱いされており、上記のコードは次のように書くこともできます

```cpp
template for (auto elem : {0, 'a', 3.14}) {
  std::cout << elem << std::endl;
}
```

この波かっこリストは初期化子リストではなく、この波かっこリストは初期化を行わずに各要素に対して直接ループが展開されます。

展開ステートメントは次のものに対して使用できます

- 構造化束縛可能なクラス型のオブジェクト
    - プレーンな構造体やタプルなど
- `constexpr`な範囲オブジェクト
    - 主に`std::vector`
- 波かっこで区切られた式のリスト（展開初期化子リスト、"expansion-init-lists"）
    - 例えば、パラメータパックも`{pack...}`とすることでループ対象になる

展開ステートメントはループな風を装っていますが、実際のところコンパイル時にループによってステートメントを生成していくのではなく、予めイテレーション対象の各要素によって生成されたステートメントの列として、範囲`for`同様に言語組み込みのマクロのような形で、一発で置換されます。とはいえ、結果のコードのインスタンス化順序や実行された時の実行順はあたかもループによって順番にステートメントが生成されていったのと同じように見えます。

この展開ステートメントは特に静的リフレクション機能と非常に相性が良い機能です。P2996R5より、列挙値を列挙値名の文字列に変換するサンプルコード

```cpp
template <typename E>
  requires std::is_enum_v<E>
constexpr std::string enum_to_string(E value) {
  template for (constexpr auto e : std::meta::enumerators_of(^E)) {
    if (value == [:e:]) {
      return std::string(std::meta::identifier_of(e));
    }
  }

  return "<unnamed>";
}

enum Color { red, green, blue };
static_assert(enum_to_string(Color::red) == "red");
static_assert(enum_to_string(Color(42)) == "<unnamed>");
```

`^E`は列挙型`E`からそのリフレクション情報を取り出しており、それに対する`std::meta::enumerators_of()`は列挙型の各列挙子のリフレクション情報を取り出しています。ここでのイテレーション対象`e`は`std::meta::info`の値で、`[:e:]`（スプライシング）によって対応する列挙値の定数値に変換することで、展開ステートメントの各ステートメントは列挙型`E`の列挙子1つに対してマッチする`if`文を生成します。

`(std::meta::identifier_of()`はリフレクション情報からそれに対応する識別子名を文字列で得るもので、ここでは`e`は列挙子を映したものなので、列挙子名がコンパイル時文字列で得られます。

この`template for`以外のものはP2996の静的リフレクション提案ですべて用意されているものです。

- [P1306 進行状況](https://github.com/cplusplus/papers/issues/156)

### [P1494R3 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1494r3.html)

因果関係を逆転するような過度な最適化を防止するためのバリアである`std::observable()`の提案。

以前の記事を参照

- [P1494R2 Partial program correctness - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1494R2-Partial-program-correctness)

このリビジョンでの変更は

- フリースタンディングでのサポートを要求
- 実装可能性を明確化
- I/O関数を暗黙的なチェックポイントとして扱うようにする代替案についての説明の追加

などです。

- [P1494 進行状況](https://github.com/cplusplus/papers/issues/376)

### [P1928R9 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r9.pdf)
### [P2019R6 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2019r6.pdf)
### [P2034R4 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2034r4.pdf)
### [P2079R4 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2079r4.html)
### [P2413R1 Remove unsafe conversions of unique_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2413r1.html)
### [P2434R1 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r1.html)
### [P2689R3 Atomic Refs Bound to Memory Orderings & Atomic Accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2689r3.html)
### [P2719R0 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2719r0.html)

型を指定する形の`new/delete`演算子カスタマイズ方法の提案。

ある型について、`new/delete`演算子をカスタマイズする方法は、クラスの静的メンバ関数として定義するか、グローバルな`new/delete`演算子をオーバーライドするかの2択です。`new/delete`演算子を型ごとにカスタマイズする場合はその型についての知識が必要となりますが、前者の方法だとそれが得られるものの型に対して侵入的にしか定義できません。一方後者の方法は非侵入的に定義できるものの、グローバルな`new/delete`を丸ごと置き換えることになる（型毎にオーバーロード可能なものの、現実には`::operator new(void*)`を丸ごと置換しているケースがほとんど）ため影響範囲が大きく、複数の翻訳単位（ライブラリ）が独自にそれを行っているとODR違反の未定義動作で厄介なバグを抱え込むことになります。

この提案では、ある型についての`new/delete`演算子の非侵入的なカスタマイズ方法を提案するものです。

この提案によるカスタム方法は、既存の`operator new/delete`のオーバーロードがタグ型を取るようになっているのの延長で、ある型`T`についての`new/delete`演算子オーバーロードはタグ型として`std::type_identity<T>`を取るようにするものです。そして、`new/delete`式が演算子を探索する過程を少し調整して、このようなオーバーロードが発見されるようにします。

この提案の前後である`new`演算子呼び出し（`new`式）に対してコンパイラが考慮する`new`演算子のシグネチャ候補と順番は次のように変化します

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// ユーザーの書くnew演算子
new (args...) T(...)

// コンパイラが考慮する演算子
T::operator new(sizeof(T), args...)
::operator new(sizeof(T), args...)
```

</td>
<td valign="top">

```cpp
// ユーザーの書くnew演算子
new (args...) T(...)

// コンパイラが考慮する演算子
T::operator new(sizeof(T), args...)
operator new(sizeof(T), type_identity<T>{}, args…)  // 👈追加
::operator new(sizeof(T), args...)
```

</td>
</tr>
</table>


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// ユーザーの書くdelete演算子
delete ptr

// コンパイラが考慮する演算子
T::operator delete(void-ptr)
::operator delete(void-ptr)
```

</td>
<td valign="top">

```cpp
// ユーザーの書くdelete演算子
delete ptr

// コンパイラが考慮する演算子
T::operator delete(void-ptr)
operator delete(void-ptr, type_identity<T>{})  // 👈追加
::operator delete(void-ptr)
```

</td>
</tr>
</table>

配列版も同様です。

セキュリティ向上のために、型毎に異なるメモリ領域に配置する（同じ型のオブジェクトを同じメモリ領域に配置する）というテクニックがあり、これによってType Confusion攻撃に対する耐性を向上させることができるようです。実際に、Appleでは自社開発のOSカーネルでこれを導入することでType Confusion脆弱性の軽減に大きな効果があったとのことです（筆者の方はAppleの方）。

カーネルに限らず、セキュリティが重要なコードベースではこのような手法を取り入れることが合理的な場合がありますが、現在のC++の`new/delete`オーバーロードはこのような手法を大規模かつシステム全体で達成することをサポートできていません。この提案の内容はそのような手法を達成するための構成要素であり、間接的にC++プログラムのセキュリティを向上させることに繋がります。

提案文書より、サンプルコード

```cpp
namespace lib {
  struct Foo { };

  void* operator new(std::size_t, std::type_identity<Foo>); // (1)

  struct Foo2 { };
}

struct Bar {
  static void* operator new(std::size_t); // (2)
};

void* operator new(std::size_t); // (3)

void f() {
  new lib::Foo();  // calls (1)
  new Bar();       // calls (2)
  new lib::Foo2(); // (1)が見つかりますがオーバーロード解決に失敗するため、(3)が呼び出される
  new int();       // calls (3)
}
```

現在コンパイラは`new`演算子の探索において、まず対象の型（`new T{}`の`T`）のクラススコープで`T::operator new()`を探索し、見つかればそれを使用します。見つからない場合、次にグローバルの`::operator new()`を探索し、見つかればそれを使用します。どちらかが見つかれば例えばそれがエラーでも探索はそれで終了します。

この提案では、グローバルな`::operator new()`を探索する前に、フリー関数の`operator new()`を考慮するようにします。その際のシグネチャは次のものです

```cpp
operator new(sizeof(T), std::type_identity<T>{}, placement-args...)
```

型`T`に対して第二引数で`std::type_identity<T>`を受け取るようにオーバーロードしておくことで、この挿入された2ステップ目の探索でそれを使わせることができるようになるわけです。そして、この探索はADLによって行われるため、名前空間内で`new/delete`演算子を定義しておくこともでき、これによってODR違反を緩和することができます。

- [型の取り違えとは(Type Confusion) | サイバー攻撃大辞典](https://securitychecklist.net/security/cyber-attack/Type-Confusion.html)
- [P2719 進行状況](https://github.com/cplusplus/papers/issues/1898)

### [P2758R3 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2758r3.html)
### [P2761R1 Slides: If structured binding (P0963R1 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2761r1.pdf)
### [P2786R6 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r6.pdf)
### [P2822R1 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r1.pdf)
### [P2830R4 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r4.html)
### [P2835R4 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r4.html)
### [P2841R3 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r3.pdf)
### [P2846R2 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r2.pdf)
### [P2849R0 async-object - aka async-RAII objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2849r0.pdf)

`sender`チェーンにRAIIリソースを注入するための、非同期オブジェクトの提案。

`sender/receiver`自体は非同期関数の実装の一部であり、P2300のフレームワークでは非同期関数は値・エラー・キャンセルのいずれかの結果によって非同期的に完了します。

非同期関数の内部で使用されるリソース（非同期オブジェクト）は、非道的処理が単一のローカルなブロックに収まるものではないため、通常手動でメモリを管理する必要があります。

`sender`アルゴリズムによるチェーンに対して値を注入するには、`let_value(value, func)`アルゴリズムを使用します。これは、`func(value)`の結果を（`receiver`の値チャネルで）返す`sender`を返すもので、そこから得られる値（`func(value)`の結果）は安定したストレージに保持されることが保証されます。

これと同種なものとして、`let_stop_source(sender, sender(inplace_stop_source&))`というアルゴリズムを考えることができます。これは、`sender`チェーンに対して`inplace_stop_source`を注入し、なおかつそれに安定的なストレージを提供するものです。この延長で、`sender`チェーンに対して多様な非同期リソースを注入するめの`let_xxx`アルゴリズムが個別に考案されつつあります。このことは、このような非同期リソースを`sender`チェーンで扱うための汎用的な設計が欠けていることを表しています。

そのような非同期コードでは多くの場合、`shared_ptr`を使用してアドホックなガーページコレクションが実装されます。このようなアドホックな非同期オブジェクトの非同期的な構築と破棄はある統一的な汎用設計に従っていない場合、汎用的なアルゴリズムからそのような非同期リソースを複数まとめて扱うことを困難にします。

この提案は、`sender/receiver`を用いた非同期オブジェクトの構築と破棄のルールをライブラリに実装する方法についてを提案するものです。

この提案では、非同期オブジェクトのための3つの基本的な要件について定義しています

- 非同期構築（*async constructio*）
    - オブジェクトの中には構築中に実行される非同期関数がある
        - ファイルを開く、通信を確立する、など
    - スレッドをブロックすることなく、構築中に非同期関数を使用できるようにする必要がある
    - コンストラクタはこれを満たすことができない
- 非同期破棄（*async destruction*）
    - オブジェクトの中には破棄中に実行される非同期関数がある
        - ファイルをフラッシュする、通信を中断する、など
    - スレッドをブロックすることなく、破棄中に非同期関数を使用できるようにする必要がある
    - デストラクタはこれを満たすことができない
- 構造化された正しい構築（*structured and correct-by-construction*）
    - ローカルスコープのオブジェクトのルールから派生した、直感的なオブジェクト構築のルール
    - structured concurrencyのコンストラクタ/デストラクタ版

これらの要件の元、この提案ではつぎの3つのものを提案しています

- 非同期オブジェクト
    - 非同期構築が正常に完了するまで使用できない
    - 非同期構築がエラーで完了する場合がある
    - 非同期構築のキャンセルをサポートする
    - 非同期破棄が失敗せず、停止できないことを保証する
- `async_using`アルゴリズム
    - 常に、内部の非同期関数を呼び出す前に非同期構築を完了する
    - 常に、内部の非同期関数が完了する前に非同期破棄を完了する
    - 常に、内部の非同期関数の完了に伴って非同期破棄を呼び出す
    - 常に、複数の非同期オブジェクトの非同期破棄を、その非同期構築の逆順で呼び出す
    - 常に、非同期構築に成功した非同期オブジェクトに対してだけ、非同期破棄を呼び出す
- `async_tuple`
    - 常に、`async_tuple`そのものの非同期構築完了の前に、内包する全ての非同期オブジェクトの非同期構築を完了する
    - 常に、内包する全ての非同期オブジェクトの非同期破棄を、その非同期構築の逆順で呼び出す
    - 常に、非同期構築に成功した内包する非同期オブジェクトに対してだけ、非同期破棄を呼び出す

非同期オブジェクト同士は組み合わせて使用することができ、その要件は次のものです

- 構成（*composition*）
    - 複数の非同期オブジェクトは、ネストせずに同時に使用可能になる
    - オブジェクト間の依存関係はネストによって表現される
    - 構成は、複数のオブジェクトの並行非同期構築をサポートする
    - 構成は、複数のオブジェクトの並行非同期破棄をサポートする

この提案が提供するのは、これらの要件を具体化した`async_object<T>`をはじめとするコンセプトと、`async_using`と`async_tuple`、および`packaged_async_object`（非同期オブジェクトとその非同期コンストラクタ引数をパッケージングするもの）です。

提案より、サンプルコード。

非同期オブジェクト型（`Foo`）の実装例

```cpp
// Fooはint値を格納する非同期オブジェクト
struct Foo {
  // 非同期オブジェクトを定義
  // 非同期オブジェクトはムーブ不可である必要がある
  struct object : __immovable {
    object() = delete;
    int v;
  private:
    // only allow Foo to run the constructor
    friend struct Foo;
    explicit object(int v) noexcept : v(v) {}
  };

  // 構築された非同期オブジェクトのハンドル型
  // これは非同期構築（async_construct()）によって生成される
  using handle = std::reference_wrapper<object>;

  // 非同期オブジェクト用のストレージを予約する型
  // nothrowデフォルト構築可能 かつ ムーブ不可である必要がある
  using storage = std::optional<object>;
  
  // async_construct()は構築された非同期オブジェクトのハンドルで完了するsenderを返す
  auto async_construct(storage& stg, int v) const noexcept {
    return then( just(std::ref(stg), v),
      [](storage& stg, int v) noexcept {
        auto construct = [&]() noexcept { return object{v}; };
        stg.emplace( __conv{construct});
        printf("foo constructed, %d\n", stg.value().v);

        return std::ref(stg.value());
      }
    );
  }

  // async_destruct() はストレージ内の非同期オブジェクトの破棄を実行し、非同期破棄が完了した後に完了するsenderを返す
  auto async_destruct(storage& stg) const noexcept {
    return then( just(std::ref(stg)),
      [](storage& stg) noexcept {
        printf("foo destructed %d\n", stg.value().v);
        stg.reset();
      }
    );
  }
};

// Fooはasync_object
static_assert(async_object<Foo>);
// Fooはintから非同期構築可能
static_assert(async_object_constructible_from<Foo, int>);
```

2つの`Foo`型の非同期オブジェクトを作成し、`sender`式で状態を変更する

```cpp
int main() {
  // 2つの非同期オブジェクトを使用するsender
  auto inner = [](Foo::handle o0, Foo::handle o1) noexcept {
    return then( just(o0, o1),
      [](Foo::handle o0, Foo::handle o1) noexcept {
        auto& ro0 = o0.get();
        auto& ro1 = o1.get();
        ro0.v = ro0.v + ro0.v;
        ro1.v = ro1.v + ro1.v;
        printf("foo pack usage, %d, %d\n", ro0.v, ro1.v);
        fflush(stdout);
        return ro0.v + ro1.v;
      }
    );
  };

  // 非同期オブジェクトとコンストラクタ引数をパッケージング
  packaged_async_object foo7{Foo{}, 7};
  packaged_async_object foo12{Foo{}, 12};

  // ストレージを予約し、2つの非同期オブジェクトを非同期構築し
  // それらが完了してからinnerの処理にそれらのハンドルを渡し
  // innerの処理が完了したら非同期オブジェクトを非同期破棄する
  // そして、それら全てが完了すると完了する非同期処理を表すsender
  auto use_s = async_using(inner, foo7, foo12);
  
  // 非同期処理開始と待機、結果取得
  auto [v] = sync_wait(use_s).value();
  printf("foo pack result %d\n\n", v);
}
```

この提案の内容は純粋なライブラリ機能であり、仮実装が公開されています : https://godbolt.org/z/rrbW6veYd

- [P2849 進行状況](https://github.com/cplusplus/papers/issues/1899)

### [P2876R1 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2876r1.html)
### [P2900R7 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r7.pdf)
### [P2963R2 Ordering of constraints involving fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2963r2.pdf)
### [P2964R1 Allowing user-defined types in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2964r1.html)
### [P2967R1 Relocation Is A Library Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2967r1.pdf)
### [P2971R2 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2971r2.pdf)
### [P2976R1 Freestanding Library: algorithm, numeric, and random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2976r1.html)
### [P2988R5 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r5.pdf)
### [P2996R3 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html)
### [P3045R1 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r1.html)
### [P3051R1 Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3051r1.html)
### [P3059R1 Making user-defined constructors of view iterators/sentinels private](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3059r1.html)
### [P3064R1 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3064r1.pdf)
### [P3067R0 Provide predefined simd permute generator functions for common operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3067r0.html)

P2664で提案されている、`std::simd`の汎用permute APIを設計し直す提案。

SIMDにおけるpermute命令とは、SIMDレジスタ内で要素を並び替える命令の1つです。ある計算の際に効率的なデータの並びとその後の別の計算の際に効率的なデータの並びが異なる場合など、SIMDレジスタ内にデータを載せたまま並べ替えが必要になることはよくあり、その際にpermute命令を使用できます。

P2664では`std::simd`に対してpermute命令に対応する並べ替えを行うための`std::permute()`を提案していましたが、P2664の`std::permute()`APIはほとんどのユーザーの最も一般的な要求をサポートするように汎用的に設計されていたため、必要なことは何でもできるもののよく使用される特定の並べ替えパターンをシンプルに記述することができず、ユーザーが個別にその操作を行う関数を定義する必要性が頻発することが想定されたようです。

この提案ではそのような並べ替え操作の目的やパターンをまとめて、この浮かび上がった要求を元にして`std::simd`の要素並べ替えを行うフリー関数のセットを特定し提案するものです。

今のところ挙げられているものは次のものです

|関数|説明|
|---|---|
|`take<int>(simd)`|`simd`の先頭から`N`要素を含む新しい`simd`オブジェクトを返す|
|`grow<int>(simd, value={})`|入力された`simd`よりも大きいサイズで、指定された`value`で初期化された新しい要素を含んだ`simd`を返す|
|`stride<int N>(simd)`|入力された`simd`の`N`番目の要素のみを含む新しい`simd`を返す|
|`chunk<int>(simd)`|既存の`simd::split`を名前変更および移動したもの|
|`reverse(simd)`|入力された`simd`と同じサイズで、要素を逆順にした新しい`simd`を返す|
|`repeat_all<int>(simd)`|入力された`simd`を`N`回繰り返した新しい`simd`を返す（例： `repeat_all<3>([a, b])`は`[a, b, a, b, a, b]`になる）|
|`repeat_each<int>(simd)`|入力された`simd`の各要素を`N`回繰り返した新しい`simd`を返する（例： `repeat_each<3>([a, b])`は`[a, a, a, b, b, b ]`になる）|
|`transpose<ROWS, COLS>(simd)`|入力された`simd`を、`ROWS`行と`COLS`列の行優先の行列として扱い、転置した結果（つまり列優先にした）を返す|
|`zip(simd...)`|入力された複数の`simd`の対応する要素を交互に並べて新しい`simd`を生成する。（例： `zip([a, b, c], [0, 1, 2])`は`[a, 0, b, 1, c, 2]`を返す|
|`unzip<N>(simd...)`|入力された`simd`を`N`個の`simd`に分割する。（例： `unzip<2>([a, 0, b, 1, c, 2])`は`make_tuple([a, b, c], [0, 1, 2])`を返す|
|`cat(simd...)`|`simd_cat`の名前変更版|
|`extract<N, M>(simd)`|`[N...M)`の範囲内の要素を含む新しい`simd`を抽出する|
|`rotate<MIDDLE>(simd)`|`simd`の要素を左に回転し、`MIDDLE` インデックスの要素が最初の要素になるようにする|
|`shift_left<N>(simd)/shift_right<N>(simd)`|入力された`simd`と同じサイズで、要素を左または右にシフトし、値初期化された要素を挿入した新しい`simd`を返す|
|`align<N>(simd a, simd b)`|2つの`simd`オブジェクトを受け取り、`cat(a, b)`から`simd`を抽出します|

これらの良く使用する並べ替え操作（順列のジェネレーター関数）をあらかじめ用意しておくことで

- 同じジェネレーター関数を繰り返し何度も重複定義することになるのを回避する
- よく使用する操作について、分かりやすい名前付き関数を提供することで、コードの可読性を向上させる
- よく使用する操作について、あらかじめ用意しておくことでバグの混入を回避する

等の利点があるとしています。

- [P2664R6 Proposal to extend std::simd with permutation API - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2664R6-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2638R0 Intel's response to P1915R0 for std::simd parallelism in TS 2 - WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P2638R0-Intels-response-to-P1915R0-for-stdsimd-parallelism-in-TS-2)
- [P3067 進行状況](https://github.com/cplusplus/papers/issues/1900)

### [P3068R2 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r2.html)
### [P3085R2 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r2.html)
### [P3091R2 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r2.html)
### [P3094R2 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r2.html)
### [P3096R1 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r1.pdf)
### [P3100R0 Undefined and erroneous behaviour are contract violations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3100r0.pdf)

UB（及びEB）を契約違反として扱うようにする提案。

C++言語を安全ではなくしている要因は実行時の未定義動作にあります。正しくコンパイルされたWell-definedなC++プログラムでも、実行時に任意の未定義動作に陥る可能性があり、未定義動作を回避できない場合それはプログラムのバグとして安全性/セキュリティ上の問題を引き起こします。特に、無効なメモリアクセスによる未定義動作は特に大きな問題で、GoogleやMicrosoftの調査によればセキュリティの脆弱性の7割が無効なメモリアクセスによる未定義動作によって発生しているとされます。

近年の安全性・セキュリティの重要性の高まりを受けて、C++プログラムが未定義動作を起こす可能性を減らすための様々な取り組みがなされています。例えば

- コードレビュー
- コーディングガイドラインの適用
- コードの様々場側面を対象にした自動テスト
- 静的解析ツールの使用
- 実行時のサニタイザーの使用

など、これらの手法を正しく適用することで、実行時に発生する可能性のある未定義動作を減らすことができます。

これらのアプローチとは異なり、C++標準化委員会はC++プログラムの未定義動作リスクを低減するために、言語そのものを進化させることができる唯一の立場にあります。C++における未定義動作は基本的に実行時の性質であることから主に2つのアプローチが可能です。

1. 未定義動作に陥るコードパスを静的に検出できる場合、そのプログラムをill-formedにできる
2. 未定義動作に陥るコードパスに実行時に到達した場合に取り得る動作の範囲を指定し、実行時にその動作を緩和する

この2つのアプローチは排他的なものではなく、相互に補完し合うことができます。

一方、現在C++26を目指して契約プログラミング機能の提案（P2900）が進行しています。契約プログラミング機能はC++言語の安全性を高める機能ではあるものの、万能薬ではなく、契約プログラミング機能はすべての未定義動作をコンパイル時に静的に検出可能にするようなものではありません。しかし、コンパイル時に検出されなかったすべての未定義動作に対して実行時にそれをハンドリングして処理するための包括的なフレームワークを、契約プログラミング機能は提供します。

この提案は、契約プログラミング機能を拡張して、未定義動作を契約違反としてハンドリングできるようにしようとするものです。

この提案のアプローチは、明示的な契約アサーションだけに契約セマンティクスを指定するのではなく、実行時に未定義動作に陥る可能性のあるコア言語構成要素に対して暗黙的に契約を指定することで、未定義動作に陥る場合を契約違反として扱えるようにし、それによって契約プログラミング機能のフレームワークの中で未定義動作をハンドリングできるようにすることを目指すものです。

例えば符号付整数の加算を考えてみます。2つの`int`型の値`a, b`を加算する場合、結果が`int`の最大値を超える（オーバーフローする）場合は現在未定義動作とされていますが、これを再解釈して、符号付整数型の加算には加算結果がオーバーフローしないという暗黙の事前条件ある、とすることができます。

符号付整数型の加算が組み込みの`operator+(int, int)`を呼び出して行われると考えると、その組み込み演算子は次のように宣言されているかのように扱われます

```cpp
int operator+(int a, int b)
  pre ((b >= 0 && a <= INT_MAX - b) // 暗黙の事前条件アサーション
   || (b < 0 && a >= INT_MIN - b));
```

この事前条件アサーションを「暗黙的」としているのは、通常の契約注釈がユーザーの手によって明示的に付加されるのに対して、この事前条件アサーションはコンパイラが暗黙的に生成して付加するものだからです。

この符号付整数型の加算オーバーフローと同様に、「操作Xについて、Yが偽（`false`）の場合、動作は未定義」というようなC++標準における未定義動作の出現を、「操作Xは、Yが真（`true`）であるという事前条件を持つ」というように置き換えることができて、明示的な（通常の）契約注釈同様にこの暗黙の契約注釈もまとめて契約プログラミング機能の上で扱うことができるようになります。

こうして実行時にハンドルされうる未定義動作には2つの種類があり、それは、安全なフォールバック動作を定義できるものとできないものです。例えば、符号付整数型の加算のオーバーフローの安全なフォールバック動作はその結果の値が有効な数値になることです。その具体的な数値の性質（飽和演算、ラップアラウンドなど）を指定する代わりに、規格のレベルで未定義動作を解除するには、有効だが未規定な値になると規定するだけで十分です。この数値を計算で使用するとおそらく間違い（バグ）ではあるものの未定義ではなくなります。整数の加算を上記のように組み込み演算子とみなすと、この安全なフォールバック動作はその本体が実行する動作そのものです。

別の例として、未初期化変数を読み取る場合、未定義動作の代わりの安全なフォールバック動作として代わりに未規定だが有効な値（例えばゼロ）を読み取る、とすることで未定義動作を安全に解除することができます。この話をどこかで聞いたことがある人もいるかもしれません、これはP2795R5によって提案されC++26に既に導入されている、Erroneous Behaviour（EB）そのものです。

EBはUB時の動作として安全なフォールバック動作を実装定義で指定し、同時に診断を推奨することでUBを解消しようとする取り組みです。P2795R5で誤ったコードの結果として動作Xを取る、としているところは、この提案において、暗黙の事前条件アサーションが破られた場合の安全なフォールバック動作がXである、というのと全く同じことです。暗黙の契約アサーションがチェックされたかどうかとは関係なく、どちらの場合も誤った状態にあるプログラムの動作について述べており、なおかつその動作は未定義ではなくWell-definedとなります。

このように、P2795R5の「Erroneous Behaviour」とこの提案の「暗黙の契約アサーション違反」という2つの言葉には互換性があります。

そして、P2795R5によればErroneous Behaviourが発生した場合、実装は次のいずれかを行うことが許可されます

- 問題の報告
- プログラムの終了
- 何もしない
    - ただしUBではない

EB時の可能な動作のこのリストは、契約違反が起きた場合の4（+1）つの契約注釈のセマンティクスのサブセットです（quick_enforce, enforce, observe, ignore, assume）。

- 診断を発行 -> observe
- プログラム終了 -> quick_enforce/enforce
- 何もしない -> ignore
    - 安全なフォールバック動作を実行する

逆に、EBのフレームワークにはこのような欠陥のハンドリングに役立つ機能が欠けています。契約プログラミング機能では、契約違反時に違反ハンドラが呼びされ、なおかつこの違反ハンドラはユーザーがカスタマイズできます。EBでは安全なフォールバック動作のない未定義動作を処理できませんが、契約の場合は可能です。

そして、この提案ではC++23以前（契約もEBもない時代）との完全な下位互換を保つオプションとして、契約注釈のセマンティクスにassumeセマンティクスを追加することを提案しています。これは`[[assume]]`属性同様に契約注釈をコードの仮定として利用することが許可されており、なおかつ契約条件はチェックされず違反ハンドラは呼び出されません。契約違反が起こると未定義動作になります。

assumeセマンティクスは従来（現在）のC++と同じ挙動であり、パフォーマンスをとにかく重視する場合に選択できるものです。これは契約プログラミング機能のオーバーヘッドを取り除き、動作とパフォーマンスの両面で現在のC++23以前の動作との後方互換性を保つためのものです。EBの場合、過去の動作に戻すためにEB個別にオプトアウトメカニズム（例えば`[[indeterminate]]`）が必要となり、規格の複雑さの面でもユーザー負担の面でもスケールしません。

その概念に互換性があり、動作状態を包含しており、C++23以前との後方互換性の一括確保も備えていることから、この提案はErroneous Behaviourを完全に包含しているといえます。そのためこの提案では、EBもまたUB同様に暗黙の契約アサーションをもつものとして扱うことを提案しています。

2種類の未定義動作のもう一つ、安全なフォールバック動作を定義できないタイプの未定義動作に対して暗黙的に付加された契約の事をこの提案では、無視できない契約アサーション（Non-ignorable implicit contract assertions）と呼んでいます。

例えば、配列の添え字アクセスを先程と同様に組み込み演算子としてみてみると次のようになります

```cpp
template <typename T, size_t N>
T& subscript(T(&array)[N], size_t index)
  pre(index < N) // 暗黙の事前条件アサーション
{
  return array[index];
}
```

この場合、この暗黙の契約アサーションが破られたときにその本体の動作を安全なフォールバック動作として扱うことはできません。メモリの安全性や型の安全性に違反する操作はこのカテゴリに分類されます。

無視できない契約アサーションに対する契約注釈のセマンティクスは制限され、ignore/observeセマンティクスで評価することができません。指定可能なセマンティクスはquick_enforce/enforce/assumeのみです。これらの評価セマンティクスは例えば、次のような実装戦略にマッピングできます

- quick_enforce : 範囲外アクセスを実行時にトラップするclangの-fbounds-safety
- enforce : アドレスサニタイザーによる実行時の検出と診断発行、およびプログラム中断
- assume : C++23以前（現在）の安全ではないデフォルトの動作

安全なフォールバック動作を持たないC++の未定義動作に対しても、同様に無視できない契約アサーションを持つものとして再解釈することで、同様のマッピングが存在します。

ここでは、契約セマンティクスのマッピングの1つとしてサニタイザーのような外部ツールがあげられています。C++プログラムのためのサニタイザーはいくつかの実装がすでに提供されていますが、いずれの実装もユーザーコードと対話するためのAPI（コールバック）が非常に貧弱であり、その統一的な指針のようなものも存在していません。

この提案では、サニタイザーも含めた外部ツールのユーザーコードとの対話APIとして、契約プログラミング機能の違反ハンドラを使用するようにするアイデアを挙げています。現時点の契約違反ハンドラは現在のサニタイザーが備えるコールバックAPIよりも充実（ユーザーが置換可能、引数で詳細な情報を取得可能）しており、この包括的なAPIによってサニタイザーをC++標準の範囲内に配置することができます。

また、このAPIのサポートは既存のサニタイザーに対して変更を強いるものではありません（そうするかは完全にオプションです）。現在の契約プログラミング機能の仕様では、デフォルトの契約違反ハンドラの動作は実装定義であり、ユーザーが違反ハンドラをカスタムすることを許可しなくても良いとされているため、既存のサニタイザーはすでにそのようなAPIに準拠していると言えます。

- [P3100 進行状況](https://github.com/cplusplus/papers/issues/1901)

### [P3103R2 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r2.html)
### [P3111R0 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r0.html)

`std::atomic`にアトミックリダクション操作を追加する提案。

アトミックリダクション操作とは、アトミックなRMW操作（`fetch_add()`のような操作）ではありますが古い値を実際にはフェッチせず、メモリモデルの観点からも読み取りを粉わないようなRMW操作の事です。

そのような、フェッチされた古い値を破棄するようなアトミックRMW操作を実行する並行アルゴリズムは高性能コンピューティングでは一般的であり、現代のハードウェアはそのような操作に対して効率的な命令を備えています。

例えば次のコードは並列にヒストグラムを求めるものです

```cpp
std::span<unsigned> data;

std::array<std::atomic<unsigned>, N> buckets;

constexpr T bucket_sz = std::numeric_limits<T>::max() / (T)N;

unsigned nthreads = std::thread::hardware_concurrency();

std::for_each_n(std::execution::par_unseq, std::views::iota(0).begin(), nthreads, 
 [&](int thread) {
  unsigned data_per_thread = data.size() / nthreads;
  T* data_thread = data.data() + data_per_thread * thread;

  for (auto e : span<T>(data_thread, data_per_thread)) {
    // ここでアトミック値に対して足しこみ（fetch_add()）が行われている
    buckets[e / bucket_sz].fetch_add(1, std::memory_order_relaxed);
  }
});
```

このコードには次の2つの問題点があります

- 正しさ（UB）
  - アトミック操作が次のいずれも満たしていないため、この並列版`for_each_n`では`execution::par`を使用するべきだった（`par_unseq`を使用しているためにUB）
    - 潜在的に同時実行され、シーケンス化されていないコンテキストでデータ競合が発生する
    - 他の関数呼び出しと同期するため、ベクトル化セーフ
- パフォーマンス
  - このプログラムでアトミックリダクション操作を使用するようにするためには、高度なコンパイラの分析が必要

`std::atomic`でアトミックリダクション操作をサポートすることでこの2つの問題を解決でき、この提案はそれを提案するものです。

この提案では、既存の`std::atomic`および`std::atomic_ref`のメンバ関数である`.fetch_xxx()`に対して`void`戻り値型の`xxx()`メンバ関数を追加することを提案しています。

提案文書より、サンプルコード

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
#include <algorithm>
#include <atomic>
#include <execution>
using namespace std;
using execution::par_unseq;

int main() {
  size_t N = 10000;
  vector<int> v(N, 0);
  atomic<int> atom = 0;
  for_each_n(par_unseq, 
     v.begin(), N,
    [&](auto& e) {
      // UB+SLOW:
      atom.fetch_add(e);
  }); 
  return atom.load();
}
```

</td>
<td valign="top">

```cpp
#include <algorithm>
#include <atomic>
#include <execution>
using namespace std;
using execution::par_unseq;

int main() {
  size_t N = 10000;
  vector<int> v(N, 0);
  atomic<int> atom = 0;
  for_each_n(par_unseq, 
     v.begin(), N,
    [&](auto& e) {
      // OK+FAST
      atom.add(e);  // 👈
  }); 
  return atom.load();
}
```

</td>
</tr>
</table>

また、この延長として、順序付けされていないときの（並列実行時の）読み取りでないアトミックメモリ操作を許可し、浮動小数点演算が結合的であると仮定して浮動小数点数型の算術リダクション操作を拡張することも追加で提案しています。

浮動小数点数の演算のように非結合的な演算では、並列に実行される演算の順序が結果に影響を与える可能性があるため、アトミックリダクション操作の効果が制限されます。例えば、`x = a + (b + c)`という計算を並列に実行する場合、アトミックリダクション操作では`(a + b) + c`や`a + (c + b)`などの異なる順序で計算される可能性があり、浮動小数点演算が結合的ではないことから結果が一致しない可能性があります。この提案の一般化アトミックリダクション操作では、浮動小数点数型のアトミックリダクション操作において浮動小数点演算が結合的であると仮定して実行することを許可することで、実装はこの制限を受けずに最適化が可能になります。

この提案では、一般化アトミックリダクション操作は浮動小数点数型の特殊化のみのメンバ関数として、上記のアトミックリダクション操作とは別名のメンバ関数として追加することを提案しています

```cpp
template <floating-point>
class atomic {
  ...

  // アトミックリダクション操作
  void add(floating-point, memory_order);
  // 一般化アトミックリダクション操作
  void add_generalizedg(floating-point, memory_order);

  ...
};
```

- [P3111 進行状況](https://github.com/cplusplus/papers/issues/1902)

### [P3119R1 Tokyo Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3119r1.pdf)
### [P3125R0 Pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r0.pdf)

タグ付きポインタをサポートするためのライブラリ機能の提案。

タグ付きポインタとは、ポインタのビットのうち使用されていない部分に情報を埋め込むこんで利用しようとするものです。主に、メモリ安全性の向上のために使用されていますが、これを利用した特殊なデータ構造もあるようです。

現代のC++の環境の多くはポインタのサイズは64bitですが、現状のメモリ容量の場合そのメモリ空間をすべて表現するのに64bitもの長さは必要ありません。アーキテクチャによるようですが、48bit目くらいまでしか使われていないようです。すると、余った上位16bitを無視するようにしてもらえば、その部分を何かしら利用することができます。x64/arm共にこのためのCPU拡張を備えています。

さらに、アドレスがNバイトにアラインされている時そのアドレスはNの倍数になるため、その分の下位数ビット（`log2(N)`ビット）も同様に利用できます。例えば、`int`型が4バイトの場合`int`型変数のアドレスは通常4の倍数の値になるため、下位2ビットはポインタ値に参加していません。

しかし、C++の規格としては有効なポインタの一部のビットを操作することは未定義動作であり、タグ付きポインタは許可されていません。この提案は、特殊なライブラリ関数を通してのみそのような操作を認めるようにしようとするものです。

提案しているのはまず、ポインタからタグ部分を取り出すビットマスクを返す関数です。

```cpp
namespace std {
  template <typename Pointee, size_t Alignment = alignof(Pointee)>
  constexpr auto tag_bit_mask() noexcept -> uintptr_t;
}
```

この`tag_bit_mask()`はポインタ型`Pointee`とアライメント`Alignment`に対して、そのポインタ型のポインタ値のうちタグとして使用可能な部分のビットが1になったビットマスクを返します。下位のビットはアーキテクチャによらず共通（アライメントで決まる）ですが、上位ビットがどこまで利用可能かはアーキテクチャおよびサニタイザーの存在によって変化します。

次に、タグ付きポインタを表す型`std::tagged_pointer<T, Alignment>`を用意して、これに対してタグ付け、タグのクリア、タグに保存されている値の取り出しを行う関数を提案しています。

```cpp
namespace std {
  // ポインタにタグ付けを行う
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto tag_pointer(T* original, uintptr_t value) noexcept -> tagged_pointer<T, Alignment>;

  // タグ付きポインタを元のポインタに戻す
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto untag_pointer(tagged_pointer<T, Alignment> ptr) noexcept -> T*;

  // タグ付きポインタからタグの値を取り出す
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto tag_value(tagged_pointer<T, Alignment> ptr) noexcept -> uintptr_t;
}
```

この提案のタグ付きポインタサポートは特殊なデータ構造（Hash-Array-Mapped-Trie (HAMT)など）の作成を許可することに重きを置いているため、これらの関数は`constexpr`が付加されています。

`std::tagged_pointer<T, alignment>`は`void*`と同じサイズで`void*`に変換できる必要があるという要件は定まっているものの、それを何にするか（`void*`、`T*`、クラス型など）はまだ決まっていないようです。

- [Memory Tagging Extension: Enhancing memory safety through architecture](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/enhancing-memory-safety)
- [64bit環境におけるObjective-Cのポインタ | GREE Engineering](https://labs.gree.jp/blog/2015/01/13437/)
- [HWAddressSanitizer  |  Android Open Source Project](https://source.android.com/docs/security/test/hwasan?hl=ja)
- [57-bits の仮想メモリアドレス空間と新機能 UAI が実装される将来の AMD プロセッサ | Coelacanth's Dream](https://www.coelacanth-dream.com/posts/2022/03/12/amd-57bit-addr-uai/)
- [P3125 進行状況](https://github.com/cplusplus/papers/issues/1903)

### [P3126R1 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r1.pdf)
### [P3130R1 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r1.pdf)
### [P3131R1 Graph Library: Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r1.pdf)
### [P3137R1 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3137r1.html)
### [P3138R1 views::cache_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r1.html)
### [P3139R0 Pointer cast for unique_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3139r0.html)

`std::const_pointer_cast`と`std::dynamic_pointer_cast`に`std::unique_ptr`のオーバーロードを追加する提案。

`std::uniqur_ptr`に対してポインタのキャスト操作を行うことはそのままではできず、現在のベストプラクティスは、一旦`.release()`してポインタを取り出した後、そのポインタに対してポインタキャストを適用してから、結果のポインタを再び`unique_ptr`でラップする、という手順です。

しかし、この手順は一旦リソースの所有権を手放す必要があるなど、リソース安全な方法とはいえません。

```cpp
auto GetClient() -> std::unique_ptr<const Client>;

// constを外したい
voif example() {
  std::unique_ptr<Client> client;
  // 生ポインタが露出する
  client.reset(const_cast<Client*>(GetClient().release()));

  ..
}

// dynamic_castを適用したい
void UseV2Client(std::unique_ptr<Client>&& client) {
  std::unique_ptr<ClientV2> v2;
  ...
  // dynamic_castが失敗するとリソースリークする
  v2.reset(dynamic_cast<ClientV2*>(client.release()));

  ...
}
```

一方で、`std::shared_ptr`にはそのキャストのためのフリー関数である`std::const_pointer_cast`と`std::dynamic_pointer_cast`が用意されており、これを用いるとこのような危険性を回避することができます。また、Boostには`unique_ptr`に対する`std::const_pointer_cast`と`std::dynamic_pointer_cast`オーバーロードが用意されています。

`std::uniqur_ptr`のポインタキャストという操作をより安全にするために、`std::uniqur_ptr`でも`std::const_pointer_cast`と`std::dynamic_pointer_cast`を使用できるようにする提案です。

方法としては単純に、`std::const_pointer_cast`と`std::dynamic_pointer_cast`に`std::uniqur_ptr`を受け取るオーバーロードを追加することでこれを行おうとしていますが、`std::unique_ptr`特有の事情により少し設計が異なる部分があります。

1つは提案するオーバーロードは`std::uniqur_ptr`の右辺値に対してのみ作用することで、もう1つはカスタムデリータの考慮です。`std::shared_ptr`の場合はカスタムデリータは型消去されて保持されており、キャストの前後でも一貫して元のポインタに対して作用するようにすることで、デリータを考慮する必要はありません。しかし、`std::unique_ptr`の場合はデリータは型の一部であり、キャストにあたってデリータを考慮する必要があります。

`std::unique_ptr<T, D>`を`std::unique_ptr<U>`にキャストする場合、`D`がキャスト後のポインタを削除できるかどうかを考える必要があります。これは単純にデフォルトのデリータを使用している場合にのみその仮定が成り立ちます。一方、`std::unique_ptr<T, D>`は`D`を通してポインタ型をカスタマイズすることができ、保持するものは実際にはポインタではない場合もあります。この場合、ユーザーが指定した`D`はキャスト後のリソースを正しく開放できる場合もあります（これはユーザーが知っています）。

そのため、この提案ではこの2つのユースケースをサポートします。すなわち、キャストは次の2パターンが可能です

1. `std::unique_ptr<T>` -> `std::unique_ptr<U>`の変換
2. `std::unique_ptr<T, D>` -> `std::unique_ptr<U, D>`の変換

提案されている関数

```cpp
namespace std {
  // dynamic_cast
  template<class T, class U>
  constexpr unique_ptr<T> dynamic_pointer_cast(unique_ptr<U>&& r) noexcept;

  template<class T, class D, class U>
  constexpr unique_ptr<T, D> dynamic_pointer_cast(unique_ptr<U, D>&& r) noexcept;

  // const_cast
  template<class T, class U>
  constexpr unique_ptr<T> const_pointer_cast(unique_ptr<U>&& r) noexcept;

  template<class T, class D, class U>
  constexpr unique_ptr<T, D> const_pointer_cast(unique_ptr<U, D>&& r) noexcept;
}
```

この提案のキャスト設計においては、安全であることを重視しています。そのため、この2種類以外のポインタキャスト（`static_cast`と`reinterpret_cast`）に対応する関数は専門知識が必要であり気軽に使用できるものではないとして提案していません。

また、キャストに当たっては静的にその危険性を検出できるものについてはチェックして弾くようにしています。次の表は、この提案のAPIに追加されているガードレールを表したものです

|API|1の変換|2の変換|
|:--|---|---|
|`const_pointer_cast`|`T* -> U*`への`const_cast`が有効であること|変換元の`::pointer`から変換先の`::pointer`への`const_cast`が有効であり、`T, U`はどちらも配列型であるかどちらも異なっている|
|`dynamic_pointer_cast`|`T* -> U*`への`dynamic_cast`が有効であり、`U`は仮想デストラクタを持つ|変換元の`::pointer`から変換先の`::pointer`への`dynamic_cast`が有効であり、`T, U`はどちらも配列型ではない|

表の右列の「変換元の`::pointer`」とは`std::unique_ptr<T, D>::pointer`のことで、「変換先の`::pointer`」とは`std::unique_ptr<U, D>::pointer`のことです。

- [`std::const_pointer_cast` - cpprefjp](https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html)
- [`std::dynamic_pointer_cast` - cpprefjp](https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html)
- [P3139 進行状況](https://github.com/cplusplus/papers/issues/1904)

### [P3149R3 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r3.html)
### [P3154R1 Deprecating signed character types in iostreams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3154r1.html)
### [P3157R1 Generative Extensions for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3157r1.html)
### [P3175R1 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r1.html)
### [P3175R2 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r2.html)
### [P3179R1 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r1.html)
### [P3183R1 Contract testing support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3183r1.pdf)
### [P3210R1 A Postcondition *is* a Pattern Match](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r1.pdf)
### [P3214R0 2024-04 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3214r0.html)

2024年4月に行われた、LEWGにおける投票の結果

次の9つの提案が投票にかけられ、リジェクトされたものはありません

- [P2985R0 A type trait for detecting virtual base classes](https://wg21.link/P2985R0)
- [P2019R5 Thread Attributes](https://wg21.link/P2019R5)
- [P2855R1 Member customization points for Senders and Receivers](https://wg21.link/P2855R1)
- [P3168R1 Give std::optional range support](https://wg21.link/P3168R1)
- [P2075R5 Philox as an extension of the C++ RNG engines](https://wg21.link/P2075R5)
- [P2927R2 Observing exceptions stored in exception_ptr](https://wg21.link/P2927R2)
- [P2997R1 Removing the common reference requirement from the indirectly invocable concepts](https://wg21.link/P2997R1)
- [P2389R1 dextents Index Type Parameter](https://wg21.link/P2389R1)
- [P3201R1 LEWG nodiscard policy](https://wg21.link/P3201R1)

P3201R1とP3201R1以外は、C++26に向けてLWGに転送するための投票です。

また、投票に当たって寄せられたコメントが記載されています。

### [P3228R1 Contracts for C++: Revisiting contract check elision and duplication](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3228r1.pdf)
### [P3234R1 Utility to check if a pointer is in a given range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3234r1.html)
### [P3235R0 `std::print` more types faster with less memory](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3235r0.html)

`std::print`の効率的な実装をより拡大して適用する提案。

P3107では`std::print`に対して、`std::format()`を使用して一旦`std::string`を得てから出力するのではなく、基底のストリームバッファをロックして直接書き込むようにすることで`std::print`の出力動作を効率化しました。ただし、これはフォーマッタ内でロックを取得するようにしている場合にその型の値に対して`std::print`を同じロックの下で呼び出す場合にデッドロックを引き起こす可能性があったため、`std::enable_nonlocking_formatter_optimization`変数テンプレートの特殊化を`true`で定義する場合にのみ有効になるようにされています。

```cpp
// フォーマットしたい型
struct foo {};

// fooのためのformatter特殊化
template <>
struct std::formatter<foo> {
  ...
};

// P3107の効率的な実装を有効化する
template <>
constexpr bool std::enable_nonlocking_formatter_optimization<foo> = true;
```

P3107では、このオプトインを基本型（`int`等組み込みの型）と文字列型（`std::string/std::string_view`）に対してのみ用意しており、他の標準型のフォーマッタに対しては有効化していませんでした。

この提案は、これら以外のフォーマッタ提供済みの標準型に対してもこのオプトインを有効化しようとするものです。

追加を提案しているものは次のものです

- `<chrono>`関連型
    - ただし、`std::zoned_time`はデフォルトの`TimeZonePtr`に対してのみ提供
- `std::thread::id`
- `<stack_trace>`関連
- `std::filesystem::path`
- `std::pair/std::tuple`
    - 要素型のすべてがオプトイン済みである場合に有効化
- `range`関連
    - `std::vector<bool>`とコンテナアダプタを含む
    - 要素型によらずに有効化
        - 反復処理の場合はデッドロック発生の可能性が低いと考えられるため

また追加の提案として、現在の`std::vprint_(non)unicode`を`std::vprint_(non)unicode_buffered`に、`std::vprint_(non)unicode_locking`を`std::vprint_(non)unicode`に変更することも提案しています。これは、非ロックオーバーロード（現在の`std::vprint_(non)unicode`）が最終的な書き込み時に`std::vprint_(non)unicode_locking`を呼び出すため、命名が誤解を招くということで修正を提案するものです。修正後の名前は、この2つの関数の違いが出力をバッファリング（全体を文字列化してから出力を行う）して行うかどうかという点が明確になります。

この提案C++23へのDRとして、2024年6月の全体会議で採択されています。

- [P3107R0 Permit an efficient implementation of `std::print`](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3107R0-Permit-an-efficient-implementation-of-stdprint)
- [P3107R5 Permit an efficient implementation of `std::print`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r5.html)
- [P3235 進行状況](https://github.com/cplusplus/papers/issues/1906)

### [P3236R1 Please reject P2786 and adopt P1144](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r1.html)
### [P3238R0 An alternate proposal for naming contract semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3238r0.html)

違反ハンドラを呼び出さずに終了する契約セマンティクス（quick_enforce）を、Erroneous Behaviorとして扱うようにする提案。

ここで提案されているのは次の2つの事です

1. 契約違反時に違反ハンドラを呼び出さず即時終了するセマンティクス（quick_enforce）を持つ契約注釈の契約違反時の動作は、Erroneous Behaviorであると指定する
    - その安全なフォールバック動作として、違反ハンドラを呼び出す
2. 契約セマンティクスの名前を変更する
    - ignore -> ignored
    - enforce -> enforced
    - observe -> observed
    - quick_enforce -> erroneous

契約違反時に即時終了するセマンティクスにおいては契約違反は致命的な失敗であり、他の方法でこの動作をフックすることはできません。これをEBとして指定することで、そのまま即時終了することと、安全なフォールバック動作として違反ハンドラを呼び出して簡単な診断を発行して終了することの両方を実装に対して許可することができます。

次にこのことを踏まえたうえでquick_enforceに対する適切な名前を考えます。他の3つの契約セマンティクスの名前は概ね「～ the trueness of a predicate」（「述語の真偽を～する」）の～の部分に当てはまるようになっていますが、quick_enforceはそうではありません。この提案ではそこに当てはまるような名前を考えるのではなく、意味上のerroneousという単語を他の名前になっている動詞の過去形と同じ文法的位置に置くようにしています。すなわち、「A contract violation is treated as ～」（契約違反は、～として扱われる）の～に入るように他の3つの名前を変更し、動詞の過去形にすることを提案しています。

この提案の内容はSG21のレビューにおいて好まれませんでした。

- [P3238 進行状況](https://github.com/cplusplus/papers/issues/1906)

### [P3239R0 A Relocating Swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3239r0.pdf)

リロケーションを用いた`swap`を行う、`swap_representations`の提案。

`swap`のセマンティクスは2つのオブジェクトのオブジェクト表現を交換することです。その操作は実際には、ムーブコンストラクタとムーブ代入演算子（とデストラクタ）によって実行されます。

オブジェクト表現の交換という部分に注目すると`swap`の行うことはリロケーションが行うこととよく似ていることに気づきます。特に、トリビアルリロケーション可能な型なら`swap`は単純な`memcpy`によって実行できます。これによって、`swap`のパフォーマンスを向上させることができます。

しかし、トリビアルなリロケーションのような操作によって2つのオブジェクトの表現を入れ替えることは、C++の非トリビアルな型のオブジェクトについての生存期間ののルールに抵触し、トリビアルリロケーション導入後においても許可されません。

この提案は、リロケーションによる`swap`を行う専用の関数をライブラリに追加し、それを通してのみリロケーションによる`swap`を合法化することを提案するものです。

提案されているのは、`std::swap_representations()`という関数です。同じ型の2つのオブジェクトへの参照を受け取って、それらのオブジェクトの値表現を交換しますが、どちらのオブジェクトの生存期間も終了しません。リロケーション操作を用いるとソースオブジェクトは消えてしまうため通常それは不可能です。そのため、この関数は一種の魔法のように動作する特別な関数です。ただし、安全のため、入力の型`T`はトリビアルリロケーション可能（`is_trivially_relocatable_v<T>`が`true`）でなければなりません。

```cpp
namespace std {
  // 提案するswap_representationsの宣言
  template <bool force, class T>
  void swap_representations(T& a, T& b); 
}
```

テンプレートパラメータの`force`は`T`がポリモルフィックな型の場合にのみ意味を持ちます。ここでの引数は参照であるため、`T`を基底クラスとした派生クラスオブジェクトへの参照が入力される可能性があります。もし、`a`と`b`が同じ基底クラス`T`から派生する別の派生クラスの参照である場合、これは未定義動作になります（`a`と`b`の仮想関数テーブルが異なっているため）。

この関数内からは参照で渡されたものしか見えないためそれを静的に検出できませんが、`swap_representations`利用者が予めこの危険性がない参照を渡すことを知っている場合（例えば、`std::vector`内部で要素型が`T`そのものであることが分かっている場合など）に、`force`パラメータを`true`にして呼び出すことでポリモルフィックな型の値表現を交換できます。逆に、`is_polymorphic_v<T>`が`true`の場合に`force`が`false`と指定されていると、コンパイルエラーになります。

また、`std::swap`がプログラムの観測可能な動作を変更することなくこれを用いて実装可能であることを示す型特性`std::swap_uses_value_representations_v`を用意することも提案しています。型`T`のオブジェクトについての`std::swap`は`std::swap_uses_value_representations_v<T>`が`true`となる場合に`swap_representations`を用いて最適化することができます。

この提案の内容はコア言語の変更を伴わないライブラリ拡張のみであり、なおかつ他のライブラリ機能に影響を及ぼさないものです。しかし、トリビアルリロケーションと共に導入されれば、そのパフォーマンス上の恩恵を最大化することができます。

- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P3239 進行状況](https://github.com/cplusplus/papers/issues/1908)

### [P3247R1 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r1.html)
### [P3248R0 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3248r0.html)

`(u)intptr_t`を必須にする提案。

`(u)intptr_t`はポインタ値を整数として保持したい場合に使用でき、変換前後でポインタ値が変化しないことが保証されている整数型のエイリアスです。しかし、このエイリアスはオプションであり、実装は必ずしも定義する必要はありません。

`(u)intptr_t`が存在しない可能性があるという事実によって、移植性を重視するソフトウェアではこの使用を回避する必要があり、そのために余計な作業と潜在的なバグを埋め込む可能性が発生します。

このことは標準ライブラリでも問題になり、P2835（`std::atomic_ref`にポインタ値を取得可能な関数を追加する）やP3125（ポインタの未使用ビット使用のための関数を追加する）などではポインタ値のやり取りのために`(u)intptr_t`を使用しようとしているものの、それがオプショナルであることが問題となっています。

この提案は、`(u)intptr_t`を必須の型エイリアスにしようとするものです。

オプショナルであるとはいえ実際には主要3コンパイラは全てのターゲット向けにこのエイリアスを提供しており、その標準ライブラリ実装も`(u)intptr_t`の存在を仮定して実装されているようです。また、プラットフォームのABIでも`(u)intptr_t`相当の整数型の存在がポインタ型の指定と共に仄めかされているようです。

従って、`(u)intptr_t`を必須にしたとしてもC++のプラットフォームサポートは低下しない、とこの提案では結論付けています。

提案している規格の変更は、`(u)intptr_t`からoptionalであるという指定を取り除くだけです。

- [`std::intptr_t` - cpprefjp](https://cpprefjp.github.io/reference/cstdint/intptr_t.html)
- [P3248 進行状況](https://github.com/cplusplus/papers/issues/1909)

### [P3249R0 A unified syntax for Pattern Matching and Contracts when introducing a new name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3249r0.pdf)

パターンマッチングと契約プログラミング機能の間で統一的な構文の提案。

パターンマッチング構文においては、パターンの記述内で（マッチしたものを表す）新しい名前を導入する必要があり、P2688のパターンマッチング提案においては`let x => expr;`の様に記述します。また、契約プログラミング機能の事後条件においては、戻り値を参照する名前を導入する必要があり、`post(r : expr)`の様に記述します。

```cpp
int f();

// パターンマッチングの例
void g() {
  int i = f();

  i match {
    42 let val => print(val); // valを導入（val == 42）
    let x => print(x); // xを導入（x != 42）
  }
}

// 契約プログラミング機能の例
int foo()
  post(ret : ret > 0) // retを導入
```

そのコンテキストで必要な変数名を導入するという側面からはこの2つは同じことをしていると見ることができ、同じことをするのに異なる構文を使用しているのは一貫性が無く初学者が覚えづらく、言語を複雑にします。

この提案は、この2つの名前導入の構文を統一することで、習得のしやすさの向上と言語の複雑さの低減を図るものです。

提案では、これらの構文を一貫して`let name => expr`のように統一することを提案しています。

```cpp
int foo()
  post( let r => r > 0) // rを導入
```

すなわち、契約プログラミング機能の構文をパターンマッチングに合わせるものです。

ただし、事後条件（`post()`）内での`let ~`はパターンマッチングではないため、そこでパターンマッチングを書きたい場合は右辺の式内に記述する必要があります。

事後条件として`(ret == 1 or ret == 2 or ret > 100)`という条件を指定したい場合の例

```cpp
// P3210の提案
int foo()
  post (
    1 => true;
    2 => true;
    let ret => ret > 100
  );

// この提案の場合
int foo()
  post ( let ret =>
    ret match {
      1 => true;
      2 => true;
    } or
    ret > 100
  );
```

これが、先行する同種の提案P3210との違いでもあります。

この提案の問題点は、契約プログラミング機能がC++26を目指しているのに対して、パターンマッチング機能はまだその段階にないことです。おそらく、契約プログラミング機能の方が先に完成し標準に取り込まれるでしょう。つまり、パターンマッチングの構文はまだ流動的で、最悪の場合この提案が採択されたうえでパターンマッチングだけ異なる構文になる可能性があります。

ただ、この提案を採択しなければ同じことを行うのに異なる2つの構文が確実に導入されるのに対して、この提案を採択したおけばそれを異なる2つの構文が導入されるかもしれない、まで緩和することができます。

契約プログラミング機能が先に採択されている場合にこの提案が採択されているとすると、パターンマッチングの構文として別のものが提案される場合にそれに対して余分な制約を追加することになります。その場合この提案では、統一構文から逸脱するにせよ整合性を重視するにせよ、それは契約プログラミング機能とは無関係にパターンマッチングが（を議論するEWGが）決定するべき、としています。

- [P3210R0 A Postcondition is a Pattern Match - WG21月次提案文書を眺める（2024年04月）](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r0.pdf)
- [P3249 進行状況](https://github.com/cplusplus/papers/issues/1910)

### [P3250R0 C++ contracts with regards to function pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3250r0.html)

契約注釈を持つ関数の関数ポインタへの暗黙変換を禁止する提案。

現在の契約プログラミング機能の仕様（P2900）では、現時点で契約チェックが関数の呼び出し側でなされるのか、呼び出し先でなされるのかが未解決のままです。とはいえ、関数ポインタの場合を除いてこれはほぼ問題にならないようです。

また現在の契約プログラミング仕様では、関数ポインタに対する契約の指定は行えません。これは、関数ポインタがそのシグネチャだけ会って居れば変換できてしまうためで、異なる契約条件の変換をどうするかという厄介な問題の議論を先送りにするための制限です。ただし、将来的にそれを有効化した場合、関数ポインタを通して関数が呼び出された場合に契約チェックを正しく行うには必ず呼び出し先でチェックを実行しなければならないことを意味して
います。

ただし、現在の仕様（P2900）では、関数ポインタに対する契約注釈を禁止しているものの、契約注釈を持つ関数の関数ポインタへの変換は禁止していません。これによって、将来的に関数ポインタに対する契約注釈への拡張が行われた場合に問題が起こります。

```cpp
// 契約を持つ関数
void fun(A& a) pre (a.ok());

// 関数型エイリアス
using F = void(A& a);
using G = void(A& a) pre(a.ok()); // 将来可能になったとして

// 関数ポインタ変数の宣言
F* f = fun; // ok、危険、現在から可能
G* g = fun; // ok、安全
```

このように同じ関数に対する関数ポインタでも、契約注釈の情報を保持したものとすべて削除されたものの2種類が共存してしまいます。

この提案は、将来の関数ポインタに対する契約注釈の指定を可能にしておくために、契約を持つ関数からシグネチャがマッチする関数ポインタヘの暗黙変換を禁止するものです。

関数ポインタに契約注釈を行えるようにする場合

- コンパイラは呼び出し先でのチェックを省略して、呼び出し側の（場合によっては省略可能な）契約条件のチェックを抱けを行える
    - コンパイラの証明によって、契約条件のチェックが省略可能な機会が増える
- 異なる契約注釈セット間での関数ポインタの変換
    - より強い契約からより弱い契約へ、またはその逆、の変換など

等のメリットがあります。

将来の関数ポインタのために設計を予約しておく場合、これらのメリットを将来的に導入する時のために設計を開いておき、なおかつ、現在の関数ポインタの使用方法を将来の変更から保護する事にもつながります。

一方、関数ポインタの契約注釈のために設計空間を予約しておく場合

- 関数名に対してアドレスを取る操作は、明示的な変換のみが許可される
- 型推論される場所で関数ポインタを使用できない
  - `auto*`やテンプレート
- P2900は契約注釈はリフレクションに対して不可視であることを決定したが、これによってそれをコンパイル時に検出出来うる

等のデメリットがあります。

提案より、サンプルコード

```cpp
int f(int x) post (r: r != 0);

using function_type = int(*)(int);
auto *fp2 = f; // ERROR
auto *fp3 = (function_type)f; // OK

template <typename FT>
void g(FT func);
g(f); // ERROR
g((function_type)f); // OK
```

契約を持たない関数の関数ポインタへの変換、および（契約有無に関わらず）関数ポインタへの明示的変換は、これまで通りに許可されます。

この提案はSG21のレビューで好まれず、否決されています。

- [P3221R0 Disable pointers to contracted functions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3221R0-Disable-pointers-to-contracted-functions)
- [P3250 進行状況](https://github.com/cplusplus/papers/issues/1911)

### [P3251R0 C++ contracts and coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3251r0.html)
### [P3253R0 Distinguishing between member and free coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3253r0.html)
### [P3254R0 Reserve identifiers preceded by @ for non-ignorable annotation tokens](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3254r0.html)
### [P3255R0 Expose whether atomic notifying operations are lock-free](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3255r0.html)
### [P3257R0 Make the predicate of contract_assert more regular](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3257r0.html)
### [P3258R0 Formatting charN_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3258r0.pdf)
### [P3259R0 const by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3259r0.html)
### [P3263R0 Encoded annotated char](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3263r0.html)
### [P3264R0 Double-evaluation of preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3264r0.html)
### [P3264R1 Double-evaluation of preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3264r1.html)
### [P3265R0 Ship Contracts in a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3265r0.html)
### [P3265R1 Ship Contracts in a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3265r1.html)
### [P3266R0 non referenceable types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3266r0.html)
### [P3267R0 C++ contracts implementation strategies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3267r0.html)
### [P3267R1 Approaches to C++ Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3267r1.html)
### [P3268R0 C++ Contracts Constification Challenges Concerning Current Code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3268r0.html)
### [P3269R0 Do Not Ship Contracts as a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3269r0.pdf)
### [P3270R0 Repetition, Elision, and Constification w.r.t. contract_assert](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3270r0.p)
### [P3271R0 Function Usage Types (Contracts for Function Pointers)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3271r0.pdf)
### [P3273R0 Introspection of Closure Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3273r0.html)
### [P3274R0 A framework for Profiles development](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3274r0.pdf)
### [P3275R0 Replace simd operator[] with getter and setter functions - or not](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3275r0.pdf)
### [P3276R0 P2900 Is Superior to a Contracts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3276r0.pdf)
### [P3278R0 Analysis of interaction between relocation, assignment, and swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3278r0.pdf)
### [P3279R0 CWG2463: What 'trivially fooable' should mean](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3279r0.html)
### [P3281R0 Contact checks should be regular C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3281r0.pdf)
### [P3282R0 Static Storage for C++ Concurrent bounded_queue](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3282r0.html)
### [P3283R0 Adding .first() and .last() to strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3283r0.html)
### [P3284R0 `finally`, `write_env`, and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r0.html)
### [P3285R0 Contracts: Protecting The Protector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3285r0.pdf)
### [P3286R0 Module Metadata Format for Distribution with Pre-Built Libraries](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3286r0.pdf)
### [P3287R0 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r0.pdf)
### [P3288R0 std::elide](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3288r0.html)
### [P3289R0 Consteval blocks](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3289r0.html)
### [P3290R0 Integrating Existing Assertions With Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3290r0.pdf)
### [P3292R0 Provenance and Concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3292r0.html)
### [P3293R0 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3293r0.html)
### [P3294R0 Code Injection with Token Sequences](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3294r0.html)
### [P3295R0 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3295r0.html)
### [P3296R0 let_with_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r0.html)
### [P3297R0 C++26 Needs Contract Checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3297r0.pdf)
### [P3298R0 Implicit user-defined conversion functions as operator.()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3298r0.pdf)
### [P3299R0 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r0.html)
### [P3301R0 inplace_stoppable_base](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3301r0.html)
### [P3302R0 SG16: Unicode meeting summaries 2024-03-13 through 2024-05-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3302r0.html)
### [P3303R0 Fixing Lazy Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3303r0.html)
### [P3304R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2024/04/10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3304r0.pdf)
### [P3305R0 SG19: Machine Learning virtual Meeting Minutes to 2024/04/11-2024/05/09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3305r0.pdf)
### [P3306R0 Atomic Read-Modify-Write Improvements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3306r0.html)
### [P3307R0 Floating-Point Maximum/Minimum Function Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3307r0.html)
### [P3308R0 mdarray design questions and answers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3308r0.html)
### [P3309R0 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r0.html)
### [P3310R0 Solving partial ordering issues introduced by P0522R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r0.html)
### [P3311R0 An opt-in approach for integration of traditional assert facilities in C++ contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3311r0.html)
### [P3312R0 Overload Set Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3312r0.pdf)
### [P3313R0 Impacts of noexept on ARM table based exception metadata](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3313r0.html)
### [P3316R0 A more predictable unchecked semantic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3316r0.pdf)
### [P3317R0 Compile time resolved contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3317r0.pdf)
### [P3318R0 Throwing violation handlers, from an application programming perspective](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3318r0.html)
### [P3319R0 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3319r0.pdf)
### [P3320R0 EWG slides for P3144 "Delete if Incomplete"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3320r0.pdf)
### [P4000R0 To TS or not to TS: that is the question](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p4000r0.pdf)
